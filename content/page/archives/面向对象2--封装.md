- # 类属性
- 类属性写在类下面
- 0、类属性可以通过：
-     类名.属性  或者  对象名.属性
- 1、如何改变类属性的值
-      类的属性修改要通过类名.属性=新值来修改
- 2、如果有多个对象，类属性有什么变化
- 
---
- #     __ del__()方法
---
- 最后调用的方法 del
- 在你执行完整个代码之后没有手动销毁的时候python解释器就会自动调用对象的__ del__
- python解释器 执行完毕的时候，有几个对象就会调用几遍__ del__
- 手动销毁也会调用del
- 有引用关系的时候p1=p3当你手动删除p1一个对象的时候
- 获取空间有几个引用关系
-       import sys别忘了引用
-       count=sys.getrefcount(对象名)注意：工具本身也占一个引用
-       print(count)

---
- # 面向对象的四大特征
---
- 数据抽象 -->表示世界中一类事物的特征,就是对象的属性.比如鸟有翅膀,羽毛等(类的属性)
- 过程抽象 -->表示世界中一类事物的行为,就是对象的行为.比如鸟会飞,会叫(类的方法)
- ### 封装
- 用名字来区分私有（"__"两个下划线开头）与共有
- 封装定义：定义私有的属性，通过公有set和get方法访问
- ##### 私有方法的使用
- 定义方式：__方法名（self）
- 只能在类内部访问，类的外部无法访问
- ##### 私有属性
- 特点：在属性名上的前面多了"__""
- 在方法里面定义私有属性是self.__ 在外面使用时不能用类名.__调用只能用self.__调用
- #### set get 结合私有使用
- 
---
- # 继承，多层继承
---
- 继承的产生
- 子类可以继承父类的属性和方法，但是父类的私有属性不能被子类继承
- 从上往下时传递继承
- ###重写父类方法与调用父类方法
- ==重写：发生在子类中，如果子类的方法与父类的方法名是相同的，则子类的方法会覆父类的方法==
- 方法名相同参数的个数不同会发生覆盖，不管参数是否一致则子类调用的就是子类自己的对象
- ### 子类中发生重写之后，如何使用父类的方法？
-     super().方法名()      第一种方法
-     super并不是一个函数，是一个类名，形如super(B, self)事实上调用了super类的初始化函数，产生了一个super对象。
-     super类的初始化函数并没有做什么特殊的操作，只是简单记录了类类型和具体实例；
-     类名.对象名(self)    第二种方法
- ### 要想调用自己的方法则通过self.方法名(参数)==如果有参数就要先定义==
- ### 多重继承
- 一个子类是允许存在多个父类
- 一个子类可以多继承，因此继承了多个父类的属性和方法
- 多继承当中照样支持重写动作
- 查看某个类调用父类方法搜寻过程
-      类名.__ mro__  
-      搜寻顺序使用C3算法
-      算法是用广度优先的算法搜寻左侧
-      python2中深度优先
-      import inspect
-      print(inspect.getmro(类名))

---
- # 多态
---
- 多态依赖父子关系
-     必须有继承了父类的子类才能算多态
- 方法中的多态
-     我可以接受任何参数进来
-     变相的把你参数窗口这里进行标注继承父类的子类都可以进来
-     

---
- # 类方法的使用
---
- 类方法前面加
-     @classmethod
-     def 方法名(cls):必须有cls参数
- cls是当前类的对象，类模型也是占用内存空间的
- 类方法的调用
-     类名.类方法名()
-     类的只能用类的
- 实例化对象都时类构建出来的
- 类模型也是一个占用内存对象，在创建对象之前就会在内存中创建类模型
- 类对象产生的时候还有没类模型创建的对象，所以类方法中是不能使用对象的东西
- ---
- ### 静态方法
-     @staicmethod
-     静态方法调用跟类方法一样的调用
- 方法可以不加self或者cls参数方法是没有参数的
- 静态方法中可以使用类属性
- 要想使用对象属性则必须要穿参，通过参数对象调用
- 如果静态方法的参数是self的话，但是与类的普通方法中的self表示的意思是不一样的self在静态方法调用的时候必须传一个参数
- 
---
# __ new__方法
---
- 通常__ new__方法由python解释器完成，通常第一个调用
-      __ new__(cls)cls表示你的类模型类对象
-      使用该方法创建当前实例对象，一般不重写，就算重写
-      也是调用父类的__ new__方法，注意：一定要返回创建的对象
-      ，如果没有返回，__ init__方法将不会被python解释器调用
-      

---
# __ call__（参数）方法
---
- 对象当作方法使用的时候   
-     可以有参数
-     text Text()
-     text();默认就会找call
-     

---
# 新式类与经典类的区别
---
    主要用于继承关系中查看上层父类是谁的
    类名.__ base__可以查看他的上一层父类是谁