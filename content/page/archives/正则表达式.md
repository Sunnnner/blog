---
- #正则表达式简介
---
- ### 正则表达式的定义
- 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
- 正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。
- 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。
- Regular	Expression的“Regular”⼀般被译为“正则”、“正规”、“常规”。
- 此处 的“Regular”即是“规则”、“规律”的意思，Regular	Expression即“描述某种规则 的表达式”之意。
- 正则表达式的特点是：灵活性、逻辑性和功能性非常强；可以迅速地用极简单的方式达到字符串的复杂控制。对于刚接触的人来说，比较晦涩难懂。
-     import re
-     使用match方法进行匹配操作
-     result = re.match(正则表达式, 要匹配的字符串)
-      如果上一步匹配到数据的话，可以使用group方法来提取数据
-      result.group()
-      如果返回None就是没有任何匹配的
-  re.match是用来进行正则匹配检查的方法，若字符串匹配正则表达式，
-  则match方法返回匹配对象（Match Object）
-  否则返回None（注意不是空字符串""）
-  匹配对象Macth Object具有group方法，用来返回字符串的匹配部分。
-  re.match() 能够匹配出以xxx开头的字符串
-  而且匹配过程中是从左到右的过程。
-  ----
-   # 表示字符
-  ----
-  
-  【^ 】表示不是这个范围的只能用一次在开头
-  
-  。匹配任意1个字符（除了\n） 
-  
-  【】匹配[	]中列举的字符 数字范围[0-9]
-  
-  \d(digit) 匹配数字，即0-9
-  
-  \D 匹配⾮数字，即不是数字
-  
-  \s(space) 匹配空白，即空格，tab
-  
-  \S 匹配非空白键(\t),\n,\r
-  
-  \w -->word  0-9 a-z A-Z 匹配单词字符 ==_==
-  
-  \W 匹配非单词字符 不是0-9 a-z A-Z  减号-不能匹配
-  
-  ---
-  # 四、表示数量
-  ---
-  * 代表0到多个\w*代表0个\w或者多个\w没有限制*代表连续的
-  
-  + 代表大于等于1至少要有1个
-  
-  ? 等于1或者0，可以没有也可以有但只能有1次
-  
-  {m}--->\d{11}表示11位手机号码 匹配前⼀个字符出现m次 
-   
-  {m，}   m数量以上没有限制
-  {m,n}   大于等于m小于等于n
-  
---
# 表示边界
---
-  ^ 匹配字符串开头
-  [^]这是非其他代表开头
-
-  $ 匹配字符串结尾
-  
-  r 在正则表达式的前面加r的区别  \  n是两个分别的字符，不加r\n就是换行
-  加r相当于\ \的效果
-  如果加了r跟$就是拿着后面的数值跟前面的正则进行匹配
-  
-  \b 匹配一个单词的边界
-  
-  \B 匹配⾮单词边界
- 
---
# 匹配分组
- | 匹配左右任意一个表达式
- 
- （ab）将括号中的字符作为一个分组
- 如果有分组从左至右0-n整体是0组
- ==如果打印groups打印出元组==
- 
- \·转义成正常·
- \number 引用分组num匹配到的字符串反向引用
- back引用
- \number指你的组的编号
- ==引用前面的内容引用的是内容不是正则表达式== 
- r代表原始字符串
-
- (?P<name>) 分组起别名
- (?P = name)引用别名为Name分组匹配到的字符串
- 


    http://[^:]+?
    
---
# 高级应用
-
-     re.srarch
-     从左边搜索，搜到第一个就推出
-     re.findall()
-     结果是列表把所有符合条件的都添加到列表
-     sub 替换
-     sub(表达式，替换内容或者函数或者匿名函数labda，原表达式)
-     

---
## spilt切割
- 
- re.spilt(r")
- 

---
# python贪婪和非贪婪
- 
- Python⾥数量词默认是贪婪的（在少数语⾔⾥也可能是默认⾮贪婪），总是 尝试匹配尽可能多的字符；
- ⾮贪婪则相反，总是尝试匹配尽可能少的字符。
- 在"*","?","+","{m,n}"后⾯加上？，使贪婪变成⾮贪婪
- 